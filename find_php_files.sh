#!/bin/bash

# Назва вихідного файлу, куди будуть записані шляхи та вміст
# Використовуємо розширення .md, оскільки формат буде схожий на Markdown
OUTPUT_FILE="php_project_dump.md"

# Директорія, в якій знаходиться скрипт (і в якій будемо шукати)
# "." означає поточну директорію
SEARCH_DIR="."
# Якщо ви хочете, щоб пошук завжди відбувався в директорії, де лежить сам скрипт,
# навіть якщо ви запускаєте його з іншого місця:
# SCRIPT_DIR=$(dirname "$(realpath "$0")")
# SEARCH_DIR="$SCRIPT_DIR"

echo "Пошук PHP файлів у директорії '$SEARCH_DIR' та всіх її піддиректоріях..."
echo "Вміст файлів буде збережено у: $OUTPUT_FILE"

# Очищуємо файл перед записом (або створюємо, якщо його немає)
# Додаємо загальний заголовок до файлу, який пояснює його структуру.
# Це допоможе LLM зрозуміти контекст.
{
  echo "# Зведення PHP файлів та їхнього вмісту"
  echo ""
  echo "<!--"
  echo "  Цей файл містить список PHP файлів та їхній повний вміст."
  echo "  Кожен файл представлений у наступному форматі:"
  echo ""
  echo "  ## File: [відносний/шлях/до/файлу.php]"
  echo ""
  echo "  \`\`\`php"
  echo "  <?php"
  echo "  // Вміст файлу тут..."
  echo "  ?>"
  echo "  \`\`\`"
  echo "-->"
  echo ""
} > "$OUTPUT_FILE" # Перезаписуємо або створюємо файл з початковим заголовком

# Лічильник файлів
file_count=0

# Використовуємо find з -print0 та read -d $'\0' для надійної обробки імен файлів,
# які можуть містити пробіли, нові рядки або інші спеціальні символи.
find "$SEARCH_DIR" -type f -name "*.php" -print0 | while IFS= read -r -d $'\0' php_file; do
    ((file_count++))
    echo "Обробка файлу: $php_file"

    # Видаляємо початковий "./" зі шляху для кращого вигляду, якщо він є.
    # Наприклад, "./src/file.php" стане "src/file.php".
    # Якщо шлях не починається з "./", він залишиться незмінним.
    clean_path="${php_file#./}"

    # Додаємо інформацію про файл та його вміст до вихідного файлу
    {
      echo "## File: $clean_path"
      echo ""
      echo "\`\`\`php" # Маркер початку блоку коду PHP (зворотні апострофи екрановані)
    } >> "$OUTPUT_FILE"

    # Записуємо вміст файлу. cat добре справляється з цим.
    # Якщо файл порожній, нічого не буде додано між маркерами блоку коду.
    cat "$php_file" >> "$OUTPUT_FILE"

    # Додаємо новий рядок після вмісту файлу, якщо його там немає.
    # Це гарантує, що закриваючий маркер ``` буде на новому рядку,
    # навіть якщо PHP-файл не закінчувався переведенням рядка.
    echo "" >> "$OUTPUT_FILE"

    {
      echo "\`\`\`" # Маркер кінця блоку коду
      echo "" # Додатковий порожній рядок для кращого візуального розділення між файлами
    } >> "$OUTPUT_FILE"
done

echo "" # Порожній рядок у консолі перед підсумком

if [ "$file_count" -eq 0 ]; then
    echo "PHP файли не знайдено у вказаній директорії '$SEARCH_DIR'."
    # Додамо повідомлення про це також у вихідний файл
    echo "PHP файли не знайдено у директорії пошуку." >> "$OUTPUT_FILE"
else
    echo "Знайдено та оброблено $file_count PHP файлів."
    echo "Результати збережено у файлі: $OUTPUT_FILE"
fi

echo "Завершено."